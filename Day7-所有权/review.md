# 学习与反思以及碎碎念
堆和栈挺熟悉的，看下来不知道的点有，在堆上申请了内存后，就要把指针放到堆里面去。栈的速度要远远优于堆，为了理解所有权系统，充分理解堆栈很重要。关于所有权，有三个非常重要的规则。
* Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
* 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
* 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

用string来举例子，如果写
```
let s = "hello";
```
这样的字面量是硬编码在里面的，是无法修改的，如果想定义一个string类型的变量。
```
let s = String::from("hello");
```
::是调用操作符，这里表示调用String中的from方法。

类似string这样的复杂类型，Rust的默认拷贝方式也是浅拷贝，也就是拷贝堆指针，长度，容量。
非常重要的是，哪怕是类似这种浅拷贝，也需要严格遵循所有权规则，例子如下：
```
let s1 = String::from("hello");
let s2 = s1;
```
这样写了之后，s1就不再拥有那个值了，等于说，赋值实际上是将所有权转让出去了，此时如果再使用s1，就会报错。
这个非常重要！和我之前学习的所有语言都有显著的区别。正如文中所说，这种与其说是浅拷贝，不如说是移动。

但有一些例外，类似int这类的基本类似，有一个叫做copy的特征，这类变量的大小是固定的，可以很方便的存在栈中，所以这种变量在进行变量绑定后，原变量是不会失效的。有一种通用的规则判断一种类型是不是基本类型：**任何基本类型的组合可以 Copy ，不需要分配内存或某种形式资源的类型是可以 Copy 的。**
一些已有的基本类型如下：
* 所有整数类型，比如`u32`
* 布尔类型`bool`
* 所有浮点数类型
* 字符类型`char`
* 元组，当且仅当其包含的类型也都是 `Copy` 的时候。比如，`(i32, i32)` 是 `Copy` 的，但 `(i32, String)` 就不是
* 不可变引用 `&T`

传入函数的参数也要遵循移动和复制的原则：
```
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
```
在这个例子里面，String作为实参传入函数中，就会函数移动，所有权就发生了变化，而int作为基本类型，传入参数中，是发生了拷贝，所有权并没有发生变化。
同样，函数返回值也有所有权

为了避免所有权转移带来的逻辑复杂性的提升，Rust引入了借用的概念。
引用和解引用好像和C的概念是一样的，&引用 *解引用。
引用也是默认不可变的，如果想要可变`&mut String`
但是可变引用也有一个限制条件，就是同一个作用域内，对于同一块内存，只允许存在一个可变引用，例子如下：
```
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;

println!("{}, {}", r1, r2);
```
这样写是不被允许的。细想其实很合理，如果在同一个作用域里面，定义第二个可变引用有什么意义呢？如果想要修改这个变量，用第一个可变引用不就可以了嘛。
为了避免数据竞争，也不允许在一个作用域内同时存在一个不可变的引用和一个可变的引用。
如果非要写，就需要用大括号限制引用的作用域。
现在新编译器，引用的作用域的结束位置从花括号变为最后一次使用这个引用的地方。

字符串在Rust里面很特别。字符串字面量不是字符串类型的，而是字符串的切片，用一个示例说明：
```
let s = String::from("hello world");    //字符串

let hello = &s[0..5];           // 切片
let world = &s[6..11];
```
这种切片方式，右区间是开区间。
在使用中文字符串的切片的时候要注意，因为一个中文字符占两字节，如果你去0字节到3字节的内存的时候，就会保存，因为有一个中文字符的内存被切为两半了。
字符串字面量是&str.
字符是固定的Unicode编码，四字节。但字符串里面就是Utf-8，就一字节。
一个字符有可能是三四个字节组成的，所以为了避免取到一个字符的前一半内存这种情况，字符串是不允许类似数组下标这样的取值方式。
如果想用unicode的方式来遍历字符串，最好使用chars()
```
for c in "中国人".chars() {
    println!("{}", c);
}
```
一个切片引用实际上只占用了两个字，一个字是指向起始地址的指针，一个字是长度
