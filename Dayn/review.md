# 学习与反思以及碎碎念
时隔了很多天重新捡起rust的学习，根据kimi推荐的学习计划，找到了一个叫rustlings的实践项目进行学习。
这段时间在工作中，使用C&C++开发遇到了很多新的问题，产生了新的思考，带着这些问题重新开始学习更加深入的感受到了rust的魅力。
## 问题0：当函数中的局部变量将自身所有权返回出去后，存储区域会变化嘛？
这个问题起源于我在学习生命周期这个专题时产生的思考，因为C&C++语言中，局部变量是不能把自身的引用返回出去的，如果返回出去，会出现访问异常内存的问题，但是Rust是支持返回局部变量的所有权的，那么这个所有权返回的过程中，这个变量是存储在哪个区域的，栈区还是堆区，如果所有权移动了，那么这个存储区域会移动嘛？
**答案（KIMI）**：
一句话答案：Rust 的“所有权转移”只是编译器层面的语义规则——移动后值仍然留在原来的栈帧里，直到函数返回、栈帧被销毁前，新所有者通过memcpy把字节复制到调用者的栈（或调用者指定的最终位置）；不会自动把数据迁到堆，也不会“整体搬家”到别的存储区域。
实际上的逻辑是，在局部变量将所有权给到返回值的时候，首先只是在语义上，移交了所有权，也就是没有发生内存的转移。但是在处理整体的函数的返回值时，调用者会将被调用者（也就是有局部变量的那个函数）的栈帧复制到调用者的栈帧中，也就是发生了栈到栈的移动，所以存储区域实际上会发生变化。
但是从编译器的角度来看，现代编译器会做NRVO
![NRVO](./md-pic/image.png)
## 问题1：当迭代器中，会抛出Result类型的数据时，应该怎么处理？
这个问题来自rustlings的习题iterator3中，在习题中，我需要对一个迭代器进行操作，在map的过程中，会返回Result的返回值，我原先希望如果返回值是error，就直接抛出异常，如果正常再继续迭代，但经过尝试发现不行，map不能直接抛出异常。
### 问题1.1：为什么map不能直接抛出异常？
答案：
正如前文所说，？实际上是返回了一个Err，但是我的map中的闭包函数签名并没有返回Result类型，闭包的返回值类型总是由**最后的表达式**或**显式指定**返回值类型来指定闭包的返回值，但我当时并没有显式指定返回值，于是闭包函数就根据最后的表达式进行推定，所以没能匹配上Result类型，所以无法使用？来抛出异常。
### 问题1.2：那么迭代器要如何抛出异常？
如果我们希望在迭代器的迭代过程中抛出异常，那么我们应该将处理的数据流转化成迭代器类型（**比如在map中，将闭包函数的返回值指定为Result类型**），在map完成后，需要使用collect收集迭代器，我们可以使用collect::<Result<Collection<T>, E>>()进行收集，在Rust标准库中，对于collect函数，有专门针对Result类型进行特殊处理，如果在处理Result类型的过程中，有Err，那么会立刻停止收集工作，并直接将Err抛出，如果并没有错误，那么会直接将Collection<T>作为结果进行返回。