# 学习与反思以及碎碎念
## 知识点1：Box<T>的存储分配
Box<T>作为智能指针，存储分配规则是，将数据分配到堆上，然后在栈上保留一个智能指针指向堆的数据。
如果想要主动将一块数据放入堆中（可能因为数据比较大），就可以主动使用Box<T>来处理。
## 知识点2：线程默认分配的栈空间大小
main主线程的默认栈空间大小为8M，其他线程的默认栈空间大小为2M
## 知识点3：Deref的作用
Deref我目前读下来最大的作用就是，当你将一个引用（**必须是引用，不能是结构体**），如&String类型的数据传入一个函数参数中，假如这个函数参数是&str类型，那么这个数据，就会一直Deref下去，直到匹配到&str这个类型的数据中。不论外面套了几层Box<T>，都可以一直解引用(**但需要在这个类型钱加上&，因为正如上文提到的必须是引用**)，且该行为是在编译器完成的，不会影响运行效率。
## 知识点4：Arc和Rc
| 类型     | 数据存放 | 引用计数     | 线程安全 |
| -------- | -------- | ------------ | -------- |
| `Box<T>` | 堆       | 无           | 是       |
| `Rc<T>`  | 堆       | 有（非原子） | 否       |
| `Arc<T>` | 堆       | 有（原子）   | 是       |
* Arc和Rc都是不可变引用，如果需要可变引用则需要配合RefCell和互斥锁Mutex
* Arc和Rc都是智能指针，实现了Deref特征，可以直接访问里面的数据，不需要额外解引用。
## 知识点5：Cell和Refcell
一句话总结：Refcell内部只是通过unsafe来绕过了所有权检查机制，但是使用者感受不到这一层抽象。本质上Refcell没有解决不可变引用和可变引用共存的问题，只是将该问题从编译期放到了运行期。
* Cell只适用于实现了Copy特征的类型，用于提供值，而Refcell是用于提供引用的。
* Cell不会panic，只有Refcell会panic
* Cell没有额外开销，Refcell有额外的运行期开销。